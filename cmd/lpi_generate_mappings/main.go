package main

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/dreadl0ck/go-dpi/modules/wrappers"
	_ "github.com/dreadl0ck/go-dpi/types" // imported for documentation
)

var categoryNames = map[uint32]string{
	0:  "WEB",
	1:  "CHAT",
	2:  "MAIL",
	3:  "P2P",
	4:  "P2P_STRUCTURE",
	5:  "KEY_EXCHANGE",
	6:  "ECOMMERCE",
	7:  "GAMING",
	8:  "ENCRYPT",
	9:  "MONITORING",
	10: "NEWS",
	11: "MALWARE",
	12: "SECURITY",
	13: "ANTISPAM",
	14: "VOIP",
	15: "TUNNELLING",
	16: "NAT",
	17: "STREAMING",
	18: "SERVICES",
	19: "DATABASES",
	20: "FILES",
	21: "REMOTE",
	22: "TELCO",
	23: "P2PTV",
	24: "RCS",
	25: "LOGGING",
	26: "PRINTING",
	27: "TRANSLATION",
	28: "CDN",
	29: "CLOUD",
	30: "NOTIFICATION",
	31: "SERIALISATION",
	32: "BROADCAST",
	33: "LOCATION",
	34: "CACHING",
	35: "MOBILE_APP",
	36: "ICS",
	37: "IPCAMERAS",
	38: "MESSAGE_QUEUE",
	39: "EDUCATIONAL",
	40: "ICMP",
	41: "MIXED",
	42: "NOPAYLOAD",
	43: "UNSUPPORTED",
	44: "UNKNOWN",
	45: "NO_CATEGORY",
}

func main() {
	fmt.Fprintf(os.Stderr, "=== libprotoident Protocol Mapping Generator ===\n\n")

	// Initialize LPI
	wrapper := wrappers.NewLPIWrapper()
	if errCode := wrapper.InitializeWrapper(); errCode != 0 {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to initialize libprotoident: error code %d\n", errCode)
		fmt.Fprintf(os.Stderr, "Make sure libprotoident is properly installed:\n")
		fmt.Fprintf(os.Stderr, "  macOS: brew install libprotoident\n")
		fmt.Fprintf(os.Stderr, "  Linux: apt-get install libprotoident-dev\n")
		os.Exit(1)
	}
	defer wrapper.DestroyWrapper()

	// Get all protocols from the installed library
	libraryProtocols := wrapper.GetAllLibraryProtocols()
	fmt.Fprintf(os.Stderr, "✓ Found %d protocols in installed libprotoident\n", len(libraryProtocols))

	// Get libprotoident version if available
	fmt.Fprintf(os.Stderr, "\nGenerating protocol mapping...\n\n")

	// Sort by protocol code
	sort.Slice(libraryProtocols, func(i, j int) bool {
		return libraryProtocols[i].Code < libraryProtocols[j].Code
	})

	// Generate the mapping
	fmt.Println("// Code generated by cmd/lpi_generate_mappings; DO NOT EDIT manually")
	fmt.Println("// This mapping was generated from the installed version of libprotoident")
	fmt.Println("//")
	fmt.Printf("// Total protocols: %d\n", len(libraryProtocols))
	fmt.Println()
	fmt.Println("var lpiCodeToProtocol = map[uint32]types.Protocol{")

	mappedCount := 0
	unmappedCount := 0
	var unmappedProtocols []wrappers.ProtocolInfo

	for _, libProto := range libraryProtocols {
		goType := protocolNameToGoType(libProto.Name)
		categoryName := categoryNames[libProto.Category]
		if categoryName == "" {
			categoryName = "UNKNOWN"
		}

		// Check if this types.Protocol exists
		if typeExists(goType) {
			fmt.Printf("\t%d: types.%s, // %s (Category: %s)\n",
				libProto.Code, goType, libProto.Name, categoryName)
			mappedCount++
		} else {
			fmt.Printf("\t// %d: %s → types.%s NOT FOUND (Category: %s)\n",
				libProto.Code, libProto.Name, goType, categoryName)
			unmappedProtocols = append(unmappedProtocols, libProto)
			unmappedCount++
		}
	}

	fmt.Println("}")

	// Print statistics to stderr
	fmt.Fprintf(os.Stderr, "\n=== Statistics ===\n")
	fmt.Fprintf(os.Stderr, "Total protocols: %d\n", len(libraryProtocols))
	fmt.Fprintf(os.Stderr, "Mapped: %d\n", mappedCount)
	fmt.Fprintf(os.Stderr, "Unmapped (need types.Protocol): %d\n", unmappedCount)

	if unmappedCount > 0 {
		fmt.Fprintf(os.Stderr, "\n⚠️  WARNING: %d protocols could not be mapped\n", unmappedCount)
		fmt.Fprintf(os.Stderr, "These protocols need to be added to types/protocols.go:\n\n")
		for _, proto := range unmappedProtocols {
			goType := protocolNameToGoType(proto.Name)
			fmt.Fprintf(os.Stderr, "  %s Protocol = \"%s\" // %s\n",
				goType, proto.Name, categoryNames[proto.Category])
		}
	}

	fmt.Fprintf(os.Stderr, "\nTo use this mapping:\n")
	fmt.Fprintf(os.Stderr, "1. Save output: go run ./cmd/lpi_generate_mappings > /tmp/new_mapping.go\n")
	fmt.Fprintf(os.Stderr, "2. Review the mapping in /tmp/new_mapping.go\n")
	fmt.Fprintf(os.Stderr, "3. Replace the lpiCodeToProtocol map in modules/wrappers/LPI_wrapper.go\n")
	fmt.Fprintf(os.Stderr, "4. Add any missing Protocol types to types/protocols.go\n")
	fmt.Fprintf(os.Stderr, "5. Run tests: go test ./...\n")
}

// protocolNameToGoType converts a libprotoident protocol name to a Go constant name
func protocolNameToGoType(name string) string {
	// Convert to uppercase and replace special characters
	goName := strings.ToUpper(name)
	goName = strings.ReplaceAll(goName, "-", "_")
	goName = strings.ReplaceAll(goName, " ", "_")
	goName = strings.ReplaceAll(goName, ".", "_")
	goName = strings.ReplaceAll(goName, "(", "")
	goName = strings.ReplaceAll(goName, ")", "")
	goName = strings.ReplaceAll(goName, "/", "_")
	goName = strings.ReplaceAll(goName, "+", "PLUS")

	// Handle special cases
	switch goName {
	case "MYSTERY":
		return "UNKNOWN"
	case "INVALID":
		return "INVALID"
	case "NO_PAYLOAD":
		return "NO_PAYLOAD"
	case "NO_FIRSTPKT":
		return "NO_FIRSTPKT"
	case "UNSUPPORTED":
		return "UNSUPPORTED"
	case "UNKNOWN":
		return "UNKNOWN"
	}

	return goName
}

// typeExists checks if a types.Protocol constant exists
// This is a best-effort check based on known types
func typeExists(name string) bool {
	// List of known types.Protocol constants
	// This should be comprehensive but may need updates
	knownTypes := map[string]bool{
		"HTTP": true, "HTTPS": true, "FTP_CONTROL": true, "FTP_DATA": true,
		"SMTP": true, "POP3": true, "IMAP": true, "SSH": true,
		"TELNET": true, "DNS": true, "DHCP": true, "NTP": true,
		"BITTORRENT": true, "GNUTELLA": true, "EMULE": true, "ARES": true,
		"IRC": true, "MSN": true, "YAHOO": true, "ICQ": true,
		"XMPP": true, "JABBER": true, "XMPPS": true,
		"RDP": true, "VNC": true, "SMB": true, "NETBIOS": true,
		"SSL": true, "TLS": true, "RTSP": true, "RTMP": true,
		"SIP": true, "RTP": true, "SKYPE": true,
		"MQTT": true, "MYSQL": true, "MONGODB": true,
		"UNKNOWN": true, "UNSUPPORTED": true, "INVALID": true,
		"NO_PAYLOAD": true, "NO_FIRSTPKT": true,
	}

	return knownTypes[name]
}
